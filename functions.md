# Functions

In this section we will compare different options to pass/accept
funtions as parameters

<table>
<tr>
    <th></th>
    <th>C++</th>
    <th>Rust</th>
</tr>


  <tr>
    <td rowspan="1">Function pointer</td>
    <td>

```cpp
int add(int a, int b) { return a + b;}

using fn_signature = int (int a, int b);
void do_work(fn_signature* f) {
    assert(f != nullptr);
    std::println("{}", f(5, 6));
}

...
do_work(add);
// captureless lambdas can be implicitly coerced to pointers
do_work([](int a, int b){return a * b;});
// or explicitly (via unary +)
do_work(+[](int a, int b){return a * b;});
// or with C++23 we can explicitly require labmda to be captureless (static)
do_work([](int a, int b) static {return a * b;});


```   
   </td>
    <td>

```rust

type FnSignature = fn (a: i32, b: i32) -> i32;

fn add(a: i32, b: i32) -> i32 { a + b }

// in Rust, function pointers are never nulls. 
// To match C/C++ world they should be wrapped in Option
// this is common case when you use ffi generators (like cbindgen)
// autogenerated C/C++ signatures will contain Option<fn...>
fn do_work(f: Option<FnSignature>) {
    let f = f.expect("non null");
    println!("{}", f(5, 6));
}

// for pure Rust-world we can benefit from non-nullability
fn do_work_safe(f: FnSignature) {
    println!("{}", f(5, 6));
}

...

do_work(Some(add));
// captureless lambdas can be implicitly coerced to pointers
do_work(Some(|a, b| { a * b }));

do_work_safe(add);
do_work_safe(|a, b| { a * b });
```
   </td>



  <tr>
    <td rowspan="2">Invocable trait / concept. Signle invocation</td>
    <td>

```cpp
void print_add(int a, int b) { std::println("{}", a + b);}

void do_work_once(std::invocable<int, int> auto&& f) {
    std::invoke(std::forward<decltype(f)>(f), 5, 6);
}

...
do_work_once(print_add);

do_work_once([w = std::make_unique<int>(42)](int x, int y) mutable {
    auto z = std::move(w); // consume internal state
    std::println("{}", x + y * *z);
});

```   
   </td>
    <td>

```rust

fn print_add(a: i32, b: i32) { println!("{}", a + b); }

fn do_work_once(f: impl FnOnce(i32, i32)) {
    f(5, 6);
}

...

do_work_once(print_add);
let w = Box::new(42);
do_work_once(move |x, y| {let z = w; println!("{}", x + y * *z)});
```
   </td>
</tr>
<tr>
   <td>
   
```C++
// with return type specified

template <typename F>
void do_work_once(F&& f) requires std::is_invocable_r_v<int, F, int, int> {
    auto r = std::invoke_r<int>(std::forward<F>(f), 5, 6);
    std::println("{}", r);
}

```
   </td>

   <td>

```Rust

fn do_work_once(f: impl FnOnce(i32, i32) -> i32){;
    std::println!("{}", f(5, 6));
}
```

   </td>
</tr>


<tr>
    <td rowspan="2">Invocable trait / concept. Multiple invocations </td>
    <td>

```cpp
void do_work_repeat(const std::invocable<int, int> auto& f) {
    for (int x = 1; x <= 5; ++x) {
        // notice that forward() is meaningless here
        // because we are acepting const&
        std::invoke(f, x, 6);
    }
}

// This will cause compilation error: function must have const operator()
do_work_repeat([i = 0](int x, int y) mutable {
    std::println("{}", x + y + i++);
});

```   
   </td>
    <td>

```rust

fn do_work_repeat(f: impl Fn(i32, i32)) {
    for x in 1..=5 {
        f(x, 6);
    }
}

```
   </td>
</tr>


<tr>
   <td>

```cpp
void do_work_repeat_mut(std::invocable<int, int> auto&& f) {
    for (int x = 1; x <= 5; ++x) {
        // notice that forward() should not be used here:
        // it's incorrect, if f has
        // consuming rvalue overload for its operator()
        std::invoke(f, x, 6);
    }
}

// Now this's fine
do_work_repeat_mut([i = 0](int x, int y) mutable {
    std::println("{}", x + y + i++);
});


```   
   </td>
    <td>

```rust

fn do_work_repeat_mut(mut f: impl FnMut(i32, i32)) {
    for x in 1..=5 {
        f(x, 6);
    }
}

```
   </td>
</tr>




<tr>
    <td rowspan="2">Dynamically dispatched functional objects</td>
    <td>

```cpp
// Prefer to avoid old std::function -- it doesn't correctly
// support refs & const/non-const operator() markers

// This snippet illustrate passing by-value 

// move-only (C++23)
// we can use && to indicate -- this function should be called only
// once
void do_work_once(std::move_only_function<void(int, int) &&> f) {
    std::jthread background([f = std::move(f)]() mutable { 
        std::move(f)(5, 6); });
}

// copyable (C++26)
void do_work(std::copyable_function<void(int, int) const> f) {
    std::jthread background1([f]{ f(5, 6); });
    std::jthread background2([f]{ f(7, 8); });
}

// jthread is used only for illustration why you may need
// to differenciate between move-only/copyable
```   
   </td>
    <td>

```rust
// to keep things simple and avoid Sync/Send/'static
// here, these examples don't use std::thread

// move-only, single use
fn do_work_once(f: Box<dyn FnOnce(i32, i32)>) {
    f(5,6);
}

// move-only, multiple use
fn do_work_repeat(f: Box<dyn Fn(i32, i32)>) {
    for x in 1..=5 {
        f(x,6);
    }
}

fn do_work_repeat_mut(f: Box<dyn FnMut(i32, i32)>) {
    for x in 1..=5 {
        f(x,6);
    }
}

// Rust doesn't have built-in Copyable dynamic functional objects
// in the same meaning as C++ std::funcion/copyable_function.
// It's not possible to have `dyn Fn() + Clone` at this moment:
// Clone trait doesn't satisfy dyn-trait requirements.

```
   </td>
</tr>


<tr>
   <td>

```cpp

// Passing by reference (C++26)

void do_work_repeat(std::function_ref<void(int, int) const> f) {
    for (int x = 1; x <= 5; ++x) {
        f(x, 6);
    }
}

void do_work_repeat_mut(std::function_ref<void(int, int)> f) {
    for (int x = 1; x <= 5; ++x) {
        f(x, 6);
    }
}


static_assert(sizeof(std::function_ref<void(int, int)>) == 2 * sizeof(void*));


```   
   </td>
    <td>

```rust

fn do_work_repeat(f: &dyn Fn(i32, i32)) {
    for x in 1..=5 {
        f(x, 6);
    }
}

fn do_work_repeat_mut(f: &mut dyn FnMut(i32, i32)) {
    for x in 1..=5 {
        f(x, 6);
    }
}

// std::function_ref and &dyn Fn have the same size.
const _ : () = {
    assert!(std::mem::size_of::<&dyn Fn(i32, i32)>() == 
            2 * std::mem::size_of::<*const i32>());
};

```
   </td>
</tr>




</table>